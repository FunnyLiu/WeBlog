---
title: 初步学习http缓存机制
date: 2016-05-25 22:24:56
categories: "web工程"
---

# **前言**

看了V神的[文章](http://www.cnblogs.com/vajoy/p/5341664.html)，根据自己的理解，整理学习笔记。

---

# **相关字段**

先看一个图片：

![images](/初步学习http缓存机制/1.png)


## **Pragma**


http1.0年代中用来控制缓存的字段，和Expires配合使用。由于http协议是向下兼容的，所以现在很多网站上依旧会带上这两个字段。

当Pragma的值为"no-cache"的时候，会通知客户端不要对该资源读缓存，即每次都得向服务器发一次请求才行。

在客户端上使用时：

``` html
<meta http-equiv="Pragma" content="no-cache">
```

可惜只有IE支持。但是如果在响应报文上加上该字段，就会有效。

## **Expires**

上面的Pragma是禁用缓存，而Expires则是启用缓存和定义缓存时间。

在客户端调用：

``` html
<meta http-equiv="expires" content="mon, 18 apr 2016 14:30:00 GMT">
```

也是只有ie支持，在服务器响应报文上添加则可以有效启用缓存：

![image](/初步学习http缓存机制/2.png)

这里需要注意Pargma的优先级大于Expires。如果同时设置两个字段，则客户端会禁用缓存。

Expires有一个缺点，就是它所定义的时间是相对服务器上的时间而言的，如果客户端修改自己的系统时间，那缓存就没什么意义了。

## **Cache-Control**

http1.1提出的缓存控制字段，在请求报文和响应报文中均可使用：
```
"Cache-Control" ":" cache-directive
```

作为请求报文首部时：

![image](/初步学习http缓存机制/3.png)

作为响应报文首部时：

![image](/初步学习http缓存机制/4.png)

我们可以自由组合：

``` 
Cache-Control: max-age=3600, must-revalidate
```

它意味着该资源是从原服务器上取得的，且其缓存（新鲜度）的有效时间为一小时，在后续一小时内，用户重新访问该资源则无须发送请求。

如果Expires，Cache-Control都有的话，就以Cache-Control为准。

以云课堂首页的一张图片为栗子：

![image](/初步学习http缓存机制/5.png)

## **Last-Modified**

前面的头部字段是设置客户端是否向服务器发请求，那么如果客户端发送了请求，是不是可以判断资源与服务器的差异从而决定是否从服务器取回实例呢？
答案是肯定的。
服务器将资源传递给客户端时，会将资源最后修改时间以Last-Modified：GMT的形式加在实体头部传动给客户端。
在第一次请求的**响应头返回 Last-Modified 内容**，时间格式如：Wed, 22 Jul 2009 07:08:07 GMT。是零时区的 GMT 时间。
客户端**请求头会为资源标记上If-Modified-Since 内容**，下次再次请求时，会把该信息附在请求报文中一并带给服务器去做检测对比，**如果没有更新，直接返回304状态码**即可。

过程如下图：

![image](/初步学习http缓存机制/6.png)

Last-Modified也**有一个问题**，就是如果服务器端资源被修改，但是仅仅是注释或者其他无所谓的修改，还是会触发修改时间。从而造成没必要的网络传输。

## **ETag**

为了解决上面说到的无所谓修改问题，http1.1还推出了ETag字段。

服务器会通过某种算法，给资源计算得出一个唯一标识，通过ETag:唯一标识，来返回客户端，客户端会保存该ETag字段，并在下一次请求时将其一并带过去给服务器，服务器只需要比较ETag是否一致，就可以很好地判断资源是否修改过。

如果Last-Modified和ETag同时启用，则需要两者都验证通过，才会返回304，否则重新请求并返回200。


---

# **实践**

原理说得差不多了，下面谈谈在实践过程中缓存的运用。

一般通过Expires来兼容旧浏览器，用Cache-Control来更精准地利用缓存，然后开启ETag和Last-Modified来进一步复用缓存减少流量。

最后说一个Chrome的状态问题，在Chrome中，只要是从本地缓存取的资源，即使没有发送请求，都会在Network面板显示一条状态为200且表明"from cache"的伪请求。